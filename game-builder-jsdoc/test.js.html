<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: test.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: test.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const MESSAGE_HANDLER_FUNCTION_NAME_PREFIX = "On";

// This is an optimization. We could remote-forward this and it would work.. but
// it's much more efficient to have VoosEngine send the RPC to other clients,
// and each client broadcasts it to their local actors.
const MESSAGES_THAT_SHOULD_NOT_BE_FORWARDED = ['ResetGame', 'Tick'];

/////// HUUUUUUUGGGGEEE TODO: This is currently duplicated with
///HandlerApi.js.txt in StreamingAssets. THE ONLY REASON WE HAVE THIS HERE..IS
///BECAUSE OF A UNITY BUG! We should probably re-structure how we load JS files
///in BehaviorSystem.cs, longer term.

/**
 * Convenience functions for common movement.
 */
class ActorMovementApi {
  constructor(api) {
    this.api_ = api;
  }

  turnLeft(revsPerSecond) {
    this.turnRight(-1 * revsPerSecond);
  }

  get dt() {
    return this.api_.dt;
  }

  turnRight(revsPerSecond) {
    const delta = new THREE.Quaternion();
    delta.setFromAxisAngle(UP_DIR, revsPerSecond * this.dt * 2 *
      Math.PI);
    const rot = this.api_.rotation;
    rot.premultiply(delta);
    this.api_.rotation = rot;
  }

  backward(maxSpeed) {
    this.forward(maxSpeed * -1);
  }

  move(deltaVector, scale = 1) {
    const pos = this.api_.position;
    pos.addScaledVector(deltaVector, scale);
    this.api_.position = pos;
  }

  forward(maxSpeed) {
    const dir = this.getForward();
    this.move(dir, this.dt * maxSpeed);
  }

  rightward(maxSpeed) {
    const dir = this.getRightward();
    this.move(dir, this.dt * maxSpeed);
  }

  getForward() {
    const dir = FORWARD_DIR.clone();
    dir.applyQuaternion(this.api_.rotation);
    return dir;
  }

  getRightward() {
    const dir = RIGHT_DIR.clone();
    dir.applyQuaternion(this.api_.rotation);
    return dir;
  }

  getInFrontOf(meters) {
    const p = this.api_.position;
    p.addScaledVector(this.getForward(), meters);
    return p;
  }

  above(meters) {
    const p = this.api_.position;
    p.addScaledVector(UP_DIR, meters);
    return p;
  }
}

/**
 * Read-only interface to read properties of other actors.
 */
class OtherActor {
  constructor(actor) {
    this.actor_ = actor;
  }

  /**
   * Get the name of this actor, for sending messages, etc.
   * @returns {string}
   */
  getName() {
    return this.actor_.name;
  }

  // BEGIN_STUGAN_CODE_GEN OTHER_ACTOR_CLASS_JAVASCRIPT
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getPosition(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.position);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.position.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.rotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getRenderableOffset(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.renderableOffset);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.renderableOffset.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getRenderableRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.renderableRotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @returns {string}    // GENERATED
   */
  getCommentText() {    // GENERATED
    return this.actor_.commentText;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getSpawnPosition(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.spawnPosition);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.spawnPosition.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getSpawnRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.spawnRotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsSolid() {    // GENERATED
    return this.actor_.isSolid;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnablePhysics() {    // GENERATED
    return this.actor_.enablePhysics;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnableGravity() {    // GENERATED
    return this.actor_.enableGravity;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnableAiming() {    // GENERATED
    return this.actor_.enableAiming;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getHideInPlayMode() {    // GENERATED
    return this.actor_.hideInPlayMode;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getKeepUpright() {    // GENERATED
    return this.actor_.keepUpright;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getUseDesiredVelocity() {    // GENERATED
    return this.actor_.useDesiredVelocity;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIgnoreVerticalDesiredVelocity() {    // GENERATED
    return this.actor_.ignoreVerticalDesiredVelocity;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getDesiredVelocity(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.desiredVelocity);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.desiredVelocity.clone();    // GENERATED
    }
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsPlayerControllable() {    // GENERATED
    return this.actor_.isPlayerControllable;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsGrounded() {    // GENERATED
    return this.actor_.isGrounded;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getWorldSpaceThrottle(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.worldSpaceThrottle);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.worldSpaceThrottle.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getInputThrottle(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.inputThrottle);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.inputThrottle.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getAimDirection(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.aimDirection);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.aimDirection.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getAimOrigin(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.aimOrigin);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.aimOrigin.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getLastAimHitPoint(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.lastAimHitPoint);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.lastAimHitPoint.clone();    // GENERATED
    }
  }
  /**
   * @returns {string}    // GENERATED
   */
  getAimingAtName() {    // GENERATED
    return this.actor_.aimingAtName;    // GENERATED
  }
  // END_STUGAN_CODE_GEN
}

/**
 * Read-write interface for the actor handling the message. This is different
 * from the main Actor class, because we don't want to expose the system-level
 * API of Actor.
 */
class HandlingActor {
  constructor(actor) {
    this.actor_ = actor;
  }

  /**
   * Get the name of this actor, for sending messages, etc.
   * @returns {string}
   */
  getName() {
    return this.actor_.name;
  }

  // BEGIN_STUGAN_CODE_GEN HANDLING_ACTOR_CLASS_JAVASCRIPT
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getPosition(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.position);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.position.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3} newPosition    // GENERATED
   */
  setPosition(newPosition) {    // GENERATED
    this.actor_.position = newPosition;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.rotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion} newRotation    // GENERATED
   */
  setRotation(newRotation) {    // GENERATED
    assert(newRotation instanceof THREE.Quaternion);    // GENERATED
    copyQuat(newRotation, this.actor_.rotation);    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getRenderableOffset(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.renderableOffset);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.renderableOffset.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3} newRenderableOffset    // GENERATED
   */
  setRenderableOffset(newRenderableOffset) {    // GENERATED
    this.actor_.renderableOffset = newRenderableOffset;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getRenderableRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.renderableRotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion} newRenderableRotation    // GENERATED
   */
  setRenderableRotation(newRenderableRotation) {    // GENERATED
    assert(newRenderableRotation instanceof THREE.Quaternion);    // GENERATED
    copyQuat(newRenderableRotation, this.actor_.renderableRotation);    // GENERATED
  }
  /**
   * @returns {string}    // GENERATED
   */
  getCommentText() {    // GENERATED
    return this.actor_.commentText;    // GENERATED
  }
  /**
   * @param {string} newCommentText    // GENERATED
   */
  setCommentText(newCommentText) {    // GENERATED
    this.actor_.commentText = newCommentText;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getSpawnPosition(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.spawnPosition);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.spawnPosition.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3} newSpawnPosition    // GENERATED
   */
  setSpawnPosition(newSpawnPosition) {    // GENERATED
    this.actor_.spawnPosition = newSpawnPosition;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion=} existing    // GENERATED
   * @returns {THREE.Quaternion}    // GENERATED
   */
  getSpawnRotation(existing = null) {    // GENERATED
    if (!existing) {    // GENERATED
      existing = new THREE.Quaternion();    // GENERATED
    }
    assert(existing instanceof THREE.Quaternion);    // GENERATED
    copyQuat(this.actor_.spawnRotation, existing);    // GENERATED
    return existing;    // GENERATED
  }
  /**
   * @param {THREE.Quaternion} newSpawnRotation    // GENERATED
   */
  setSpawnRotation(newSpawnRotation) {    // GENERATED
    assert(newSpawnRotation instanceof THREE.Quaternion);    // GENERATED
    copyQuat(newSpawnRotation, this.actor_.spawnRotation);    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsSolid() {    // GENERATED
    return this.actor_.isSolid;    // GENERATED
  }
  /**
   * @param {boolean} newIsSolid    // GENERATED
   */
  setIsSolid(newIsSolid) {    // GENERATED
    this.actor_.isSolid = newIsSolid;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnablePhysics() {    // GENERATED
    return this.actor_.enablePhysics;    // GENERATED
  }
  /**
   * @param {boolean} newEnablePhysics    // GENERATED
   */
  setEnablePhysics(newEnablePhysics) {    // GENERATED
    this.actor_.enablePhysics = newEnablePhysics;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnableGravity() {    // GENERATED
    return this.actor_.enableGravity;    // GENERATED
  }
  /**
   * @param {boolean} newEnableGravity    // GENERATED
   */
  setEnableGravity(newEnableGravity) {    // GENERATED
    this.actor_.enableGravity = newEnableGravity;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getEnableAiming() {    // GENERATED
    return this.actor_.enableAiming;    // GENERATED
  }
  /**
   * @param {boolean} newEnableAiming    // GENERATED
   */
  setEnableAiming(newEnableAiming) {    // GENERATED
    this.actor_.enableAiming = newEnableAiming;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getHideInPlayMode() {    // GENERATED
    return this.actor_.hideInPlayMode;    // GENERATED
  }
  /**
   * @param {boolean} newHideInPlayMode    // GENERATED
   */
  setHideInPlayMode(newHideInPlayMode) {    // GENERATED
    this.actor_.hideInPlayMode = newHideInPlayMode;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getKeepUpright() {    // GENERATED
    return this.actor_.keepUpright;    // GENERATED
  }
  /**
   * @param {boolean} newKeepUpright    // GENERATED
   */
  setKeepUpright(newKeepUpright) {    // GENERATED
    this.actor_.keepUpright = newKeepUpright;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getUseDesiredVelocity() {    // GENERATED
    return this.actor_.useDesiredVelocity;    // GENERATED
  }
  /**
   * @param {boolean} newUseDesiredVelocity    // GENERATED
   */
  setUseDesiredVelocity(newUseDesiredVelocity) {    // GENERATED
    this.actor_.useDesiredVelocity = newUseDesiredVelocity;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIgnoreVerticalDesiredVelocity() {    // GENERATED
    return this.actor_.ignoreVerticalDesiredVelocity;    // GENERATED
  }
  /**
   * @param {boolean} newIgnoreVerticalDesiredVelocity    // GENERATED
   */
  setIgnoreVerticalDesiredVelocity(newIgnoreVerticalDesiredVelocity) {    // GENERATED
    this.actor_.ignoreVerticalDesiredVelocity = newIgnoreVerticalDesiredVelocity;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getDesiredVelocity(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.desiredVelocity);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.desiredVelocity.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3} newDesiredVelocity    // GENERATED
   */
  setDesiredVelocity(newDesiredVelocity) {    // GENERATED
    this.actor_.desiredVelocity = newDesiredVelocity;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsPlayerControllable() {    // GENERATED
    return this.actor_.isPlayerControllable;    // GENERATED
  }
  /**
   * @param {boolean} newIsPlayerControllable    // GENERATED
   */
  setIsPlayerControllable(newIsPlayerControllable) {    // GENERATED
    this.actor_.isPlayerControllable = newIsPlayerControllable;    // GENERATED
  }
  /**
   * @returns {boolean}    // GENERATED
   */
  getIsGrounded() {    // GENERATED
    return this.actor_.isGrounded;    // GENERATED
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getWorldSpaceThrottle(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.worldSpaceThrottle);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.worldSpaceThrottle.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getInputThrottle(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.inputThrottle);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.inputThrottle.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getAimDirection(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.aimDirection);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.aimDirection.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getAimOrigin(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.aimOrigin);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.aimOrigin.clone();    // GENERATED
    }
  }
  /**
   * @param {THREE.Vector3=} existing    // GENERATED
   * @returns {THREE.Vector3}    // GENERATED
   */
  getLastAimHitPoint(existing = null) {    // GENERATED
    if (existing) {    // GENERATED
      existing.copy(this.actor_.lastAimHitPoint);    // GENERATED
      return existing;    // GENERATED
    }
    else {
      return this.actor_.lastAimHitPoint.clone();    // GENERATED
    }
  }
  /**
   * @returns {string}    // GENERATED
   */
  getAimingAtName() {    // GENERATED
    return this.actor_.aimingAtName;    // GENERATED
  }
  // END_STUGAN_CODE_GEN
}

/**
 * Exposes all the things user-written handlers are allowed to do.
 */
class HandlerApi {
  constructor(actor, use, deliveredMessage) {
    assert(actor instanceof Actor);
    assert(use instanceof ModuleBehaviorUse);
    assert(typeof deliveredMessage.name == 'string');
    assert(typeof deliveredMessage.gameTime == 'number');

    this.actor_ = actor;
    this.handlingActor_ = new HandlingActor(actor);
    this.use_ = use;
    this.deliveredMessage_ = deliveredMessage;
    this.move = new ActorMovementApi(this);
  }

  /**
   * Performs a good ol' raycast. Note that this will return all hits along the
   * ray, not just the first one. So it "goes through" actors. So keep
   * 'maxDistance' reasonable.
   * @param {THREE.Vector3} origin 
   * @param {THREE.Vector3} direction 
   * @param {number} maxDistance 
   * @returns {Array.&lt;string>} Array of actor names that the ray hit.
   */
  raycast(origin, direction, maxDistance) {
    return callVoosService('Raycast', { origin: origin, direction: direction, maxDistance: maxDistance });
  }

  /**
   * Find all actors inside a sphere.
   * @param {THREE.Vector3} center 
   * @param {number} radius 
   * @returns {Array.&lt;string>} Array of actor names that touch the given sphere.
   */
  overlapSphere(center, radius) {
    return callVoosService('OverlapSphere', { center: center, radius: radius });
  }

  /**
   * This is the main way to access the current actor's properties, such as its
   * position. Because this is the current handling actor, you can modify its
   * properties as well.
   * @returns {HandlingActor} The current actor that your handler is running
   * for.
   */
  getActor() {
    return this.handlingActor_;
  }

  /**
   * DEPRECATED - Please use getActor().getName() instead.
   * @deprecated
   */
  get name() {
    return this.actor_.name;
  }

  /**
   * DEPRECATED - Please use getActor() instead.
   * @deprecated
   */
  get actor() {
    return this.actor_;
  }

  /**
   * Get the data associated with the message you're handling. The contents of
   * this completely depends on the message.
   * @returns {object}
   */
  get message() {
    return this.deliveredMessage_.data;
  }

  /**
   * Access your declared properties. For example, if you declared "property
   * Number health", you would access it like: api.properties.health
   * @returns {object}
   */
  get properties() {
    return this.use_.properties;
  }

  /**
   * Shortcut for 'properties'.
   * @returns {object}
   */
  get props() {
    return this.use_.properties;
  }

  /**
   * Access (read and write) the handling actor's memories.
   * @returns {object}
   */
  get memory() {
    return this.actor_.memory;
  }

  /**
   * DEPRECATED - Please use getActor().getPosition() instead.
   * @deprecated
   */
  get position() {
    return this.actor_.position.clone();
  }

  /**
   * DEPRECATED - Please use getActor().setPosition() instead.
   * @deprecated
   */
  set position(newPos) {
    this.actor_.position.copy(newPos);
  }

  /**
   * DEPRECATED - Please use getActor().getRotation() instead.
   * @deprecated
   */
  get rotation() {
    return this.actor_.getRotation();
  }

  /**
   * DEPRECATED - Please use getActor().setRotation() instead.
   * @deprecated
   */
  set rotation(quat) {
    return this.actor_.setRotation(quat);
  }

  /**
   * 
   * @param {string} targetActorName 
   * @param {string} messageName 
   * @param {object} messageData 
   */
  sendMessage(targetActorName, messageName, messageData = {}) {
    this.actor_.behaviorSystem.sendMessage(targetActorName, messageName, messageData);
  }

  /**
   * 
   * @param {string} messageName 
   * @param {object} messageData 
   */
  sendMessageToAll(messageName, messageData = {}) {
    this.actor_.behaviorSystem.sendMessageToAll(messageName, messageData);
  }

  /**
   * 
   * @param {string} messageName 
   * @param {object} messageData 
   */
  sendSelfMessage(messageName, messageData = {}) {
    this.sendMessage(this.actor_.name, messageName, messageData);
  }

  /**
   * 
   * @param {number} seconds 
   */
  async sleep(seconds) {
    return this.actor_.behaviorSystem.sleepManager.for(this.actor_.name, seconds);
  }

  /**
   * The time, in seconds, since the last Tick. Only valid for OnTick handlers.
   * @returns {number}
   */
  get dt() {
    return this.deliveredMessage_.data.dt;
  }

  /**
   * Convenience function, only valid if the actor has "Takes damage".
   * @returns {boolean}
   */
  isDead() {
    const health = this.memory.health;
    // If undefined, this is not a damageable thing, so it's not knocked out.
    return health !== undefined &amp;&amp; health &lt;= 0;
  }

  isAttached() {
    return this.actor.transformParent ? true : false;
  }

  /**
   * Use this to read properties of another actor. Remember, you can *only* read
   * other actors, you can not modify them. The main way to interact with other
   * actors is by sending them messages (see sendMessage(...))
   * @param {string} name The name of the actor you'd like to inspect.
   * @returns {OtherActor} A read-only interface for the actor, with functions like getPosition()
   */
  getOtherActor(name) {
    const actor = this.getOtherActor_(name);
    if (actor) {
      return new OtherActor(actor);
    }
    else {
      return null;
    }
  }

  /**
   * DEPRECATED - Please use getOtherActor(name) instead.
   * @deprecated
   */
  getOtherActor_(name) {
    return this.actor_.behaviorSystem.getActor(name);
  }

  /**
   * DEPRECATED - Please use getOtherActor(name).getPosition() instead.
   * @deprecated
   */
  getOtherPosition(name) {
    return this.getOtherActor_(name).position.clone();
  }

  /**
   * DEPRECATED - Please use getOtherActor(name).getRotation() instead.
   * @deprecated
   */
  getOtherRotation(name) {
    return this.getOtherActor_(name).getRotation();
  }

  getOtherVelocity(name) {
    return this.getOtherActor_(name).velocity.clone();
  }

  // Read-only access to another actor's memories.
  getOtherMemory(name, key) {
    const memValue = this.getOtherActor_(name).memory[key];
    if (memValue === undefined) {
      return undefined;
    }
    if (memValue === null) {
      return null;
    }
    // My cheap way of creating a copy...
    const json = JSON.stringify(memValue);
    return JSON.parse(json);
  }

  getOtherCloneParent(name) {
    return this.getOtherActor_(name).cloneParent;
  }

  getOtherDisplayName(name) {
    return this.getOtherActor_(name).displayName;
  }

  /**
   * DEPRECATED - Please use getOtherActor(name).getIsPlayerControllable() instead.
   * @deprecated
   */
  getOtherIsPlayerControllable(name) {
    return this.getOtherActor_(name).isPlayerControllable;
  }

  /**
   * Create a new actor based on a source actor.
   * @param {string} sourceName The name of the actor that is being cloned
   * @param {THREE.Vector3} initialPosition 
   * @param {THREE.Quaternion} initialRotation 
   * @returns {string} The name of the new actor (the clone)
   */
  clone(sourceName, initialPosition, initialRotation) {
    return this.actor_.behaviorSystem.clone(sourceName, this.name, initialPosition, initialRotation);
  }

  /**
   * Destroys the handling actor.
   */
  destroySelf() {
    if (this.actor_.isLocalActor) {
      this.actor_.behaviorSystem.destroy(this.actor_);
    }
  }

  /**
   * Like doesActorExist, but also returns 'false' if name is undefined or empty.
   * @param name The name of the actor to check.
   * @returns {boolean}
   */
  isValidActor(name) {
    return name &amp;&amp; this.doesActorExist(name);
  }

  /**
   * 
   * @param name The name of the actor to check.
   * @returns {boolean}
   */
  doesActorExist(name) {
    return this.actor_.behaviorSystem.doesActorExist(name);
  }

  doesActorHaveTag(name, tag) {
    if (!this.doesActorExist(name)) {
      return false;
    }
    return this.actor_.behaviorSystem.getActor(name).tags.includes(tag);
  }

  /**
   * @param {string} first The first actor
   * @param {string} second The second actor
   * @returns {number} The distance, in meters, from the first to the second actor.
   */
  distanceBetween(first, second) {
    return this.getOtherPosition(first).distanceTo(this.getOtherPosition(second));
  }

  addPlayerToolTip(playerName, keyCode, text) {
    response.playerToolTips.push({ playerName: playerName, keyCode: keyCode, text: text });
  }

  /**
   * DEPRECATED - Please use getActor().getAimDirection() instead.
   * @deprecated
   */
  get aimDirection() {
    return this.actor_.aimDirection.clone();
  }

  /**
   * DEPRECATED - Please use getActor().getAimOrigin() instead.
   * @deprecated
   */
  get aimOrigin() {
    return this.actor_.aimOrigin.clone();
  }

  /**
   * DEPRECATED - Please use getActor().getInputThrottle() instead.
   * @deprecated
   */
  get inputThrottle() {
    return this.actor_.inputThrottle.clone();
  }

  /**
   * DEPRECATED - Please use getActor().getWorldSpaceThrottle() instead.
   * @deprecated
   */
  get worldSpaceThrottle() {
    return this.actor_.worldSpaceThrottle.clone();
  }

  /**
   * DEPRECATED - Please use getActor().getSpawnPosition() instead.
   * @deprecated
   */
  get spawnPosition() {
    return this.actor_.spawnPosition.clone();
  }

  /**
   * Set the tint. R, G, B should all be from 0 to 1.
   * @param {number} r 
   * @param {number} g 
   * @param {number} b 
   */
  setTintRGB(r, g, b) {
    this.actor_.tint.r = r;
    this.actor_.tint.g = g;
    this.actor_.tint.b = b;
  }

  setOpacity(a) {
    this.actor_.tint.a = a;
  }

  /**
   * Call this to prevent your handler from being called again for a certain
   * number of seconds. Useful for things like grace periods, cooldowns for
   * abilities, etc.
   * @param {number} deltaSeconds 
   */
  setCooldown(deltaSeconds) {
    this.actor_.setCooldown(this.use_.id, this.deliveredMessage_.name, this.deliveredMessage_.gameTime + deltaSeconds);
  }

  // Hum. Not really sure if I want this interface..
  sendMessageToUnity(message) {
    assert(typeof message == 'string');
    this.actor_.behaviorSystem.sendMessageToUnity(this.name, message);
  }

  /**
   * @returns {number} The absolute game time, in seconds.
   */
  get time() {
    return this.deliveredMessage_.gameTime;
  }
}

// State needed when running a handler for a particular actor.
// Needed to make sure we don't trigger multiple instances of a single coroutine and store any
// other context needed (such as perhaps deferred messages).
class HandlerContext {
  constructor(handler, actor) {
    assert(typeof handler == 'function');
    assert(actor instanceof Actor);

    this.handler_ = handler;
    this.actor_ = actor;
    this.isRunning_ = false;
    this.hasThrownException_ = false;
  }

  maybeHandle(deliveredMessage, use) {
    assert(use instanceof ModuleBehaviorUse);
    // Run the behavior function, and note that we're running it.
    // Once it resolves, note that we're done. If the function isn't even async,
    // it should resolve at the end of this frame, and next frame we'll just run it again.
    // If it is async, it will resolve whenever the async operation is done, and
    // in the mean time we will not run it again.
    if (!this.isRunning_ &amp;&amp; !this.hasThrownException_) {
      this.isRunning_ = true;
      const api = new HandlerApi(this.actor_, use, deliveredMessage);
      try {
        let rv = this.handler_(api);
        if (rv instanceof Promise) {
          rv.then(() => {
            // Catch memory errors early, and within the context of this handler.
            this.cleanMemories_();
            this.isRunning_ = false;
          }).catch(exception => {
            this.onException_(exception, deliveredMessage);
          });
        }
        else {
          // Did not return a promise - ie. probably returned nothing.
          // Immediately mark as not running.
          this.isRunning_ = false;
        }

        // Catch memory errors early, and within the context of this handler.
        this.cleanMemories_();
      }
      catch (exception) {
        this.onException_(exception, deliveredMessage);
      }
    }
  }

  cleanMemories_() {
    cleanSerializable(`Memory for actor ${this.actor_.displayName} (id: ${this.actor_.name})`, this.actor_.memory);
  }

  onException_(exception, deliveredMessage) {
    this.hasThrownException_ = true;
    this.isRunning_ = false;
    logError(
      `Error while handling message '${deliveredMessage.name}' for actor ${this.actor_.displayName} (uid: ${this.actor_.name}). Will not run this handler for this actor until behavior is updated. Exception:\n${exception.stack}`
    );
  }
}

class Actor {
  constructor(name, behaviorSystem) {
    assert(behaviorSystem instanceof ModuleBehaviorSystem);
    this.behaviorSystem_ = behaviorSystem;
    this.name = name;
    this.localScale = new THREE.Vector3();
    this.velocity = new THREE.Vector3();

    this.handlerCooldownMap_ = new Map();

    // This is a json-able copy
    // TODO actually use this...
    this.handlerCooldowns = [];

    // This will be a map of maps, for use -> handler -> context.
    // We can have many instances of a behavior/handler on a single actor, thus the two levels.
    // This is NOT serialized, and it only helps to keep track of coroutine state, which we can't serialize.
    this.handlerContexts_ = new Map();

    // BEGIN_STUGAN_CODE_GEN ACTOR_FIELDS_CONSTRUCTOR_JAVASCRIPT
    this.position = new THREE.Vector3();    // GENERATED
    this.rotation = { x: 0, y: 0, z: 0, w: 1 };    // GENERATED
    this.renderableOffset = new THREE.Vector3();    // GENERATED
    this.renderableRotation = { x: 0, y: 0, z: 0, w: 1 };    // GENERATED
    this.spawnPosition = new THREE.Vector3();    // GENERATED
    this.spawnRotation = { x: 0, y: 0, z: 0, w: 1 };    // GENERATED
    this.desiredVelocity = new THREE.Vector3();    // GENERATED
    this.worldSpaceThrottle = new THREE.Vector3();    // GENERATED
    this.inputThrottle = new THREE.Vector3();    // GENERATED
    this.aimDirection = new THREE.Vector3();    // GENERATED
    this.aimOrigin = new THREE.Vector3();    // GENERATED
    this.lastAimHitPoint = new THREE.Vector3();    // GENERATED
    // END_STUGAN_CODE_GEN

    // We could perhaps put the runtime stuff elsewhere, that we can clear to
    // unclutter the return JSON.

  }

  // Use these instead of accessing rotation directly.
  getRotation() {
    const rv = new THREE.Quaternion();
    copyQuat(this.rotation, rv);
    return rv;
  }

  // Use these instead of accessing rotation directly.
  setRotation(quat) {
    assert(quat.x !== undefined);
    assert(quat.y !== undefined);
    assert(quat.z !== undefined);
    assert(quat.w !== undefined);
    copyQuat(quat, this.rotation);
  }

  getCooldownKey(useId, messageName) {
    // TODO can we do better?
    return `${useId}/${messageName}`;
  }

  setCooldown(useId, messageName, expireTimeSeconds) {
    const key = this.getCooldownKey(useId, messageName);
    this.handlerCooldownMap_.set(key, expireTimeSeconds);
  }

  // Here we enforce handler-cooldowns.
  isAllowedToHandle(useId, deliveredMessage) {
    const key = this.getCooldownKey(useId, deliveredMessage.name);
    const cooldownEndTime = this.handlerCooldownMap_.get(key);
    if (cooldownEndTime != undefined) {
      if (cooldownEndTime &lt;= deliveredMessage.gameTime) {
        this.handlerCooldownMap_.delete(key);
        return true;
      }
      else {
        return false;
      }
    }
    else {
      return true;
    }
  }

  getHandlerContext(use, handler) {
    assert(use instanceof ModuleBehaviorUse);
    assert(typeof handler == 'function');
    const contextsByHandler = mapGetOrCreate(this.handlerContexts_, use, () => new Map());
    return mapGetOrCreate(contextsByHandler, handler, () => new HandlerContext(handler, this));
  }

  copyForCloning(src) {
    this.copyPersistedFields_(src);
  }

  copyPersistedFields_(src) {
    this.version = src.version;

    // 'src' can be another actor or a JSON object..trying to have my cake and eat it too here :P
    // ideally we could code-gen both of these.
    assert(src.position);
    assert(src.velocity);
    assert(src.rotation);
    assert(src.localScale);

    this.velocity.copy(src.velocity);
    this.localScale.copy(src.localScale);

    this.transformParent = src.transformParent;
    this.memoryJson = src.memoryJson;
    this.brainName = src.brainName;
    this.tags = src.tags;
    this.renderableUri = src.renderableUri;
    this.tint = {
      r: src.tint.r,
      g: src.tint.g,
      b: src.tint.b,
      a: src.tint.a
    };

    this.debugString = src.debugString;
    this.displayName = src.displayName;

    // BEGIN_STUGAN_CODE_GEN ACTOR_PERSISTED_FIELDS_MERGE_JSON_JAVASCRIPT
    this.position.copy(src.position);    // GENERATED
    copyQuat(src.rotation, this.rotation);    // GENERATED
    this.renderableOffset.copy(src.renderableOffset);    // GENERATED
    copyQuat(src.renderableRotation, this.renderableRotation);    // GENERATED
    this.commentText = src.commentText;    // GENERATED
    this.spawnPosition.copy(src.spawnPosition);    // GENERATED
    copyQuat(src.spawnRotation, this.spawnRotation);    // GENERATED
    this.isSolid = src.isSolid;    // GENERATED
    this.enablePhysics = src.enablePhysics;    // GENERATED
    this.enableGravity = src.enableGravity;    // GENERATED
    this.enableAiming = src.enableAiming;    // GENERATED
    this.hideInPlayMode = src.hideInPlayMode;    // GENERATED
    this.keepUpright = src.keepUpright;    // GENERATED
    this.useDesiredVelocity = src.useDesiredVelocity;    // GENERATED
    this.ignoreVerticalDesiredVelocity = src.ignoreVerticalDesiredVelocity;    // GENERATED
    this.desiredVelocity.copy(src.desiredVelocity);    // GENERATED
    this.isPlayerControllable = src.isPlayerControllable;    // GENERATED
    // END_STUGAN_CODE_GEN

  }

  mergeJsonObject(src, runtimeSrc) {
    assert(src.name == this.name);
    this.copyPersistedFields_(src);

    this.isLocalActor = runtimeSrc.isLocalActor;

    // BEGIN_STUGAN_CODE_GEN ACTOR_RUNTIME_FIELDS_MERGE_JSON_JAVASCRIPT
    this.isGrounded = runtimeSrc.isGrounded;    // GENERATED
    this.worldSpaceThrottle.copy(runtimeSrc.worldSpaceThrottle);    // GENERATED
    this.inputThrottle.copy(runtimeSrc.inputThrottle);    // GENERATED
    this.aimDirection.copy(runtimeSrc.aimDirection);    // GENERATED
    this.aimOrigin.copy(runtimeSrc.aimOrigin);    // GENERATED
    this.lastAimHitPoint.copy(runtimeSrc.lastAimHitPoint);    // GENERATED
    this.aimingAtName = runtimeSrc.aimingAtName;    // GENERATED
    // END_STUGAN_CODE_GEN

    if (this.memory == undefined || runtimeSrc.isMemoryAuthoritative) {
      // Take the given JSON as source of truth.
      this.memory = parseJsonOrEmpty(this.memoryJson);
    }
  }

  // Ideally we could automatically maintain this invariant. Hum.
  prepareForJsoning() {
    cleanSerializable(`Memory for actor ${this.displayName} (id: ${this.name})`, this.memory);
    this.memoryJson = JSON.stringify(this.memory);
  }

  handleMessage(deliveredMessage) {
    if (!this.brainName) {
      return;
    }

    const brain = deliveredMessage.behaviorDatabase.getBrain(this.brainName);

    if (!brain) {
      // For now, we won't consider this an error.
      return;
    }

    brain.handleMessage(this, deliveredMessage);
  }

  get behaviorSystem() {
    return this.behaviorSystem_;
  }
}

class ModuleBehavior {
  constructor(moduleKey) {
    assert(typeof moduleKey == 'string');
    assert(getVoosModule(moduleKey), `Could not find behavior module for key ${moduleKey}`);
    this.moduleKey_ = moduleKey;
  }

  getHandlerFor_(messageName) {
    assert(getVoosModule(this.moduleKey_), `Could not find module for key ${this.moduleKey_}. How did we get here?`);
    return getVoosModule(this.moduleKey_)[`${MESSAGE_HANDLER_FUNCTION_NAME_PREFIX}${messageName}`];
  }

  canHandleMessage(messageName) {
    assert(typeof messageName == 'string');
    return this.getHandlerFor_(messageName) != undefined;
  }

  handleMessage(deliveredMessage, actor, use) {
    assert(actor instanceof Actor);

    const handler = this.getHandlerFor_(deliveredMessage.name);

    if (!handler) {
      log(`Behavior ${this.moduleKey_} does not handle ${deliveredMessage.name} - ignoring.`);
      return;
    }
    const context = actor.getHandlerContext(use, handler);
    context.maybeHandle(deliveredMessage, use);
  }

  getModuleKey() {
    return this.moduleKey_;
  }

  forHandlerNames(func) {
    for (let handlerName in getVoosModule(this.moduleKey_)) {
      func(handlerName);
    }
  }
}

class ModuleBehaviorUse {
  constructor(useId, jsonUse, behavior) {
    assert(behavior);
    assert(behavior instanceof ModuleBehavior);
    this.id = useId;
    this.behavior = behavior;
    this.brainId = jsonUse.brainId;

    this.properties = {};
    jsonUse.propertyAssignments.forEach(assignment => {
      this.properties[assignment.propertyName] = JSON.parse(assignment.valueJson).value;
    });
  }
}

class ModuleBehaviorBrain {
  constructor(name, behaviorUses) {
    this.name_ = name;
    this.behaviorUses_ = behaviorUses;
  }

  forUsesHandling_(messageName, func) {
    // TEMP TEMP actually filter, not all
    this.behaviorUses_.forEach(use => func(use));
  }

  handleMessage(actor, deliveredMessage, context) {
    this.forUsesHandling_(deliveredMessage.name, use => {
      assert(use instanceof ModuleBehaviorUse);
      if (use.behavior.canHandleMessage(deliveredMessage.name)
        &amp;&amp; actor.isAllowedToHandle(use.id, deliveredMessage)) {
        use.behavior.handleMessage(deliveredMessage, actor, use);
      }
    });
  }
}

class ModuleBehaviorDatabase {
  constructor() {
    this.tempBrain = null;
    this.brainsByName_ = new Map();
  }

  getBrain(brainName) {
    assert(typeof brainName == 'string');
    return this.brainsByName_.get(brainName);
  }

  reset(jsonDb) {
    assert(typeof jsonDb == 'object');

    // Lazily create the ones that are actually used, and reuse them.
    const behaviorsByUri = new Map();

    // Create ModuleBehaviorUse instances
    const uses = [];
    for (let i = 0; i &lt; jsonDb.behaviorUses.length; i++) {
      const useId = jsonDb.behaviorUseIds[i];
      assert(typeof useId == 'string');
      const jsonUse = jsonDb.behaviorUses[i]

      const behavior = mapGetOrCreate(behaviorsByUri, jsonUse.behaviorUri, () => new ModuleBehavior(jsonUse.behaviorUri));
      uses.push(new ModuleBehaviorUse(useId, jsonUse, behavior));
    }

    const usesByBrain = groupArrayBy(uses, use => use.brainId);

    this.brainsByName_.clear();
    usesByBrain.forEach((uses, brainId) => {
      const brain = new ModuleBehaviorBrain(brainId, uses);
      this.brainsByName_.set(brainId, brain);
    })
  }
}

class ModuleBehaviorSystem {
  constructor() {
    this.actors_ = new Map();
    this.database_ = new ModuleBehaviorDatabase();
    this.sleepManager_ = new SleepManager(actorName => this.getActor(actorName) != undefined);
    this.messageQueue_ = new Queue();
  }

  update(deltaSeconds, gameTimeSeconds) {
    this.sleepManager_.update(deltaSeconds * 1e3);
    this.pumpMessageQueue_(gameTimeSeconds);
  }

  resetAllActorsToSpawn_() {
    this.actors_.forEach(actor => {
      actor.position.copy(actor.spawnPosition);
      copyQuat(actor.spawnRotation, actor.rotation);
      actor.velocity.set(0, 0, 0);

      // TODO angular velocity
    });
  }

  destroyAllClones() {
    let clones = [];
    this.actors_.forEach(actor => {
      if (actor.memory.isClone) {
        clones.push(actor);
      }
    });
    clones.forEach(clone => this.destroy(clone));
  }

  maybeSendMessageToActor_(actor, deliveredMessage, shouldRemoteForward) {
    // It's perfectly possible that actors get destroyed before the message is sent, so just check for it.
    if (actor === undefined) {
      return;
    }

    try {
      if (actor.isLocalActor) {
        actor.handleMessage(deliveredMessage);
      }
      else {
        if (shouldRemoteForward) {
          log(`remote enqueueing message ${deliveredMessage.name} to ${actor.displayName}`);
          enqueueRemoteMessage(actor.name, deliveredMessage.name, deliveredMessage.data);
        }
      }
    }
    catch (e) {
      logError(`Exception while asking ${actor.displayName} (${actor.name}) to handle message ${deliveredMessage.name}. Skipping it. The exception: ${e.stack}`);
    }
  }

  pumpMessageQueue_(gameTimeSeconds) {
    while (!this.messageQueue_.isEmpty()) {
      const item = this.messageQueue_.dequeue();

      const deliveredMessage = { name: item.messageName, data: item.messageData, gameTime: gameTimeSeconds, behaviorDatabase: this.database_ };
      const shouldRemoteForward = !MESSAGES_THAT_SHOULD_NOT_BE_FORWARDED.includes(item.messageName);

      if (item.toActorName) {
        const actor = this.actors_.get(item.toActorName);
        this.maybeSendMessageToActor_(actor, deliveredMessage, shouldRemoteForward);
      }
      else {
        // Broadcasted.

        // This feels a bit hacky...but I guess the behaviors system itself should have a message interface too.
        if (item.messageName == "ResetGame") {
          this.destroyAllClones();
          this.resetAllActorsToSpawn_();
          queueMessageToUnity(null, "ResetGame");
        }

        this.forActorsHandling_(item.messageName, actor => {
          this.maybeSendMessageToActor_(actor, deliveredMessage, shouldRemoteForward);
        });
      }
    }
  }

  get sleepManager() {
    return this.sleepManager_;
  }

  mergeActorJsonObjects(actorJsonObjects, actorRuntimeJsonObjects) {
    assert(actorJsonObjects.length == actorRuntimeJsonObjects.length);

    for (let i = 0; i &lt; actorJsonObjects.length; i++) {
      const actorJsonObj = actorJsonObjects[i];
      const runtimeObj = actorRuntimeJsonObjects[i];
      const actor = mapGetOrCreate(this.actors_, actorJsonObj.name, () => new Actor(actorJsonObj.name, this));
      actor.mergeJsonObject(actorJsonObj, runtimeObj);
    }

    // Remove missing ones
    const stillExistingNames = new Set();
    actorJsonObjects.forEach(actorJsonObj => {
      stillExistingNames.add(actorJsonObj.name);
    });

    const namesToRemove = [];
    this.actors_.forEach(actor => {
      if (!stillExistingNames.has(actor.name)) {
        namesToRemove.push(actor.name);
      }
    });

    namesToRemove.forEach(name => this.actors_.delete(name));
  }

  forActorsHandling_(messageName, func) {
    if (messageName != 'Tick') {
      log(`WARNING: linear scan for message ${messageName}`);
    }
    // TEMP TODO for now, just yield everything
    this.actors_.forEach((actor, name) => {
      func(actor);
    });
  }

  getActor(name) {
    assert(typeof name == 'string');
    return this.actors_.get(name);
  }

  doesActorExist(name) {
    return this.getActor(name) !== undefined;
  }

  // MAJOR TODO there's a bunch of logic we need to implement for remote actors, etc.
  // For now, avoid using these directly from user code...
  sendMessage(toActorName, messageName, messageData) {
    assert(toActorName);
    assert(this.doesActorExist(toActorName), `Message ${messageName} doesn't have a valid toActor: ${toActorName}`);
    if (messageData) {
      cleanSerializable(`Message data for message ${messageName} to ${toActorName}`, messageData);
    }
    this.messageQueue_.enqueue({ toActorName: toActorName, messageName: messageName, messageData: messageData });
  }

  // MAJOR TODO there's a bunch of logic we need to implement for remote actors, etc.
  // For now, avoid using these directly from user code...
  sendMessageToAll(messageName, messageData) {
    if (messageData) {
      cleanSerializable(`Message data for message-to-all ${messageName}`, messageData);
    }
    this.messageQueue_.enqueue({ toActorName: null, messageName: messageName, messageData: messageData });
  }

  getActorJsonArray() {
    const rv = [];
    this.actors_.forEach(actor => {
      actor.prepareForJsoning();
      rv.push(actor);
    });
    return rv;
  }

  resetDatabase(jsonObject) {
    this.database_.reset(jsonObject);
  }

  clone(sourceName, creatorName, initialPosition, initialRotation) {
    const maxActors = 500;
    if (this.actors_.size >= maxActors) {
      throw new Error(`There are over ${maxActors} actors. This is likely a scripting bug? To be safe, no more cloning from script will be allowed.`);
    }
    const parentActor = this.getActor(sourceName);
    assert(parentActor, `Tried to clone ${sourceName} for creator ${creatorName}, but ${sourceName} does not exist.`);

    // Creator and register
    const cloneName = THREE.Math.generateUUID();
    const cloneActor = new Actor(cloneName, this);
    this.actors_.set(cloneName, cloneActor);

    // Copy parent's attributes
    parentActor.prepareForJsoning();
    cloneActor.copyForCloning(parentActor);

    // Override some things.
    // TODO probably cleaner to have this in Actor?
    Object.assign(cloneActor, {
      displayName: `${parentActor.displayName}-Clone`,
      creatorName: creatorName,
      cloneParent: sourceName,
      // Memories do NOT get cloned.
      memoryJson: '{}',
      memory: {},
      isLocalActor: true
    });
    cloneActor.position.copy(initialPosition);
    copyQuat(initialRotation, cloneActor.rotation);
    cloneActor.memory.isClone = true;

    return cloneName;
  }

  /**
   * 
   * @param {Actor} actor 
   */
  destroy(actor) {
    assert(typeof actor == "object");
    // Only local actors may request to be destroyed.
    if (!actor.isLocalActor) {
      return;
    }
    this.actors_.delete(actor.name);
  }

  /**
   * @param {string} fromActor
   * @param {string} message 
   */
  sendMessageToUnity(targetActor, message) {
    queueMessageToUnity(targetActor, message);
  }
}

class ImmutableActorClassic {
  constructor(name) {
    this.name_ = name;
  }

  getName() {
    return this.name_;
  }
}

class MutableActorClassic extends ImmutableActorClassic {
  constructor(name) {
    super(name);
  }

  setName(name) {
    this.name_ = name;
  }
}

runUnitTests('ModuleBehaviors', {
  testImmutableInterface: function () {
    const immutable = new ImmutableActorClassic('immutable');
    assert(immutable.getName() == 'immutable');
    try {
      immutable.setName('what happens here?');
    }
    catch (e) { }
    // The set should've failed
    assert(immutable.getName() == 'immutable');
  },
  testMutableInterface: function () {
    const mutable = new MutableActorClassic('mutable');
    assert(mutable.getName() == 'mutable', 'initial name should be as given');
    mutable.setName('new name');
    assert(mutable.getName() == 'new name', 'setting name should work');
  },
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActorMovementApi.html">ActorMovementApi</a></li><li><a href="HandlerApi.html">HandlerApi</a></li><li><a href="HandlingActor.html">HandlingActor</a></li><li><a href="OtherActor.html">OtherActor</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Oct 19 2018 22:25:36 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
